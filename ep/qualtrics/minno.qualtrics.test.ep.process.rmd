```{r}
#Change to your own directory (where you keep the data file)
dir = 'C:\\Users\\yoav\\Documents\\bigfiles\\qualtrics.iat\\gal.elinor\\raw'
```

```{r}
# Copied from Elad Zlotnick (from here: https://github.com/eladzlot/minnojs-qiat/blob/master/qiat.R)
# Parse csv generated by minnoJS
#
# @param df a data frame
# @param id the column name holding the ids
# @param data the column name holding the data (we assume the data holds an array of unnested objects)
#
# @example
# qiat.parse.quoted(df, 'ResponseId', 'Q_47')
# qiat.parse(df, ResponseId, Q_47)
#
# @returns data frame with parsed data, rows with NA or '' are omitted.
qiat.parse.quoted = function(df, id, data){
  # @TODO does not work?
  # if (is.factor(df[id])) stop(paste0(data, ' column must not be a factor'))
  filteredDF = df[df[,data]!='' & !is.na(df[,data]) ,]
  
  # parse data -> list of data data frames
  csvList = lapply(filteredDF[,data], function(str) tryCatch({
    read.csv(text=str,stringsAsFactors = FALSE)
  },
  error = function(err){
    message('woa there is a malformed csv here')
    return(NA)
  }
  ))
  #browser()
  # add id to each data DF
  mask = which(sapply(csvList,nrow)>0)
  dataPages = mapply(
    function(id, df) cbind(id,df),
    filteredDF[mask,id],
    csvList[mask],
    SIMPLIFY = FALSE
  )
  
  if (!length(dataPages)) { return(data.frame()) }
  
  # concat pages
  do.call(rbind,dataPages)
}

qiat.parse = function(df, id, data){
  qiat.parse.quoted(df, deparse(substitute(id)), deparse(substitute(data)))
}
```

```{r}
###Read your file here.

df = read.csv(paste(dir, 'examplePriming-update.csv',sep = '\\'))

#Keep only the Q2, which, in our case, is the data from Minno
df <- df[which(grepl('block', df$Q2)),]

```



```{r}
#The escaping in the data sometimes uses "" which we need to change to " for the parsing.
#Note Q3 in my data was the columns that saved the IAT data for each participant. It might have a different name in your data. 
library(kutils)
df$ep <- mgsub(df$Q2, pattern = c('""'), replacement = c('"'))
```

```{r}
#Use Elad's parsing function
df2 <- qiat.parse.quoted(df = df, id='ResponseId', data = 'ep')
```

```{r}
#Sanity check: see the names of the variables.
nrow(df2)
names(df2)
#If successful, these should be:  "id"    "block" "trial" "cond"  "type"  "cat"   "stim"  "resp"  "err"   "rt"    "fb"    
```

```{r}
table(df2$block, exclude=NULL)

#Make sure the 'compatible' trials are indeed what you expected them to be.
table(df2$cond, exclude=NULL)
```

```{r}
df2$prime <- ifelse(grepl('Black', df2$cond), 'black', 
                          ifelse(grepl('White', df2$cond), 'white', NA))
table(df2$prime)

df2$target <- ifelse(grepl('Unpleasant', df2$cond), 'bad', 
                          ifelse(grepl('Pleasant', df2$cond), 'good', NA))
table(df2$target)
```

From hereafter, analyze the results however you decide. I will only show the means here, without excluding any trials other than error trials. 

```{r}
df2.correct <- df2[which(df2$err==0),]
library(doBy)
ep.means <- summaryBy(formula = rt ~ id + prime + target, data = df2.correct)
summaryBy(formula = rt.mean ~ prime + target, data = ep.means, FUN = c(mean, sd, median))
```
